#include "arduino_secrets.h"
/* 
  Sketch generated by the Arduino IoT Cloud Thing "DrawingControls"
  https://create.arduino.cc/cloud/things/878a5415-0ed8-4101-82b0-085b333df90d 

  Arduino IoT Cloud Properties description

  The following variables are automatically generated and updated when changes are made to the Thing properties

  bool StartDrawing;
  int SpeedMotor1;
  int SpeedMotor2;
  int Directions;
  bool LightDrawing;

  Properties which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"

// Extra tabs are not saved. Only in the repository sources.
// #include "const.h"

// ------- from const.h
/*
 * Headers definitions of the program
 */

// ======================== RGB LED =====================
// RGB LED control pins. Accordingly with the MKR 1000 pinout the
// contorl pins should be PWM output to create a single-led 
// NeoPixel-like colour shading
#define REDPIN 4
#define GREENPIN A3
#define BLUEPIN 5
#define RGBLED_OFF 0    // PWM value to set the LED off
#define RGB_MIN 1       // Absolute min PWM value for LED glowing
#define RGB_MAX 32     // Absolute max PWM value for LED glowing
#define RGB_MID 1     // Mid PWMlight value
#define RGB_UP 1
#define RGB_DOWN -1

// ======================== MOTORS DRIVER ===============
// The motors driver is an L298N board controller. As I am using
// two DC motors, a single bridge board is sufficient to manage
// both independently. The four motors power signals should be
// just a digital ouput while every motor speed is controlled by
// the corresponding Enable pin connected to a PWM digital output
#define ENABLE_MOTOR_A 2  // Enable signal (PWM)
#define ENABLE_MOTOR_B 3  // Enable signal (PWM)
#define MOTOR_A1 6        // Motor control line
#define MOTOR_A2 7        // Motor control line
#define MOTOR_B1 8        // Motor control line
#define MOTOR_B2 9        // Motor control line

// Motor direcitons. A tri=-state flag controlled by the cloud
#define DIRECITON_CLOCKWISE 0
#define DIRECTION_COUNTERCLOCWISE 1
#define DIRECTION_OPPOSITE 2

#define MOTOR_CLOCKWISE 0
#define MOTOR_COUNTERCLOCKWISE 1
#define MOTOR_STOPPED 0     /// PWM value to stop a motor
// ------- const.h END

/*
 * Motor control parameters.
 * This structu is constantly updated wile the design is running
 * and by the IoT cloud callback used to interact with the machine
 */
 struct MotorControl {
  int directionA = MOTOR_CLOCKWISE;
  int directionB = MOTOR_CLOCKWISE;
  int speedA = MOTOR_STOPPED;
  int speedB = MOTOR_STOPPED;
 };

/*
 * Light drawing parmeters. Depending on the state of the program, the
 * lights are glowing with the RGB range
 */
struct LightControl {
  int valGlow = 0;
  int directionGlow = RGB_UP;
};

MotorControl drawing;
LightControl glowing;

// Initilaization
void setup() {
   // Initialize serial and wait for port to open:
  Serial.begin(9600);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500); 

 // Defined in thingProperties.h
  initProperties();
  // Initializes motors and initial light state
  initHardware();
  
  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  
  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâ€™ll get.
     The default is 0 (only errors).
     Maximum is 4
 */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
}

void loop() {
  ArduinoCloud.update();

  // Check if should glow the LED
  if(LightDrawing == true) {
      lightMono();
      // lightGlow();
  }
  
}

// ========================================================================
//                            Local functions
// ========================================================================

/**
 * Initializes the I/O PINS and the initials running status and light mode
 */
void initHardware() {
  pinMode(ENABLE_MOTOR_A, OUTPUT);
  pinMode(ENABLE_MOTOR_B, OUTPUT);
  pinMode(MOTOR_A1, OUTPUT);
  pinMode(MOTOR_A2, OUTPUT);
  pinMode(MOTOR_B1, OUTPUT);
  pinMode(MOTOR_B2, OUTPUT);
  // Set initial rotation direction
  digitalWrite(MOTOR_A1, HIGH);
  digitalWrite(MOTOR_A2, LOW);
  digitalWrite(MOTOR_B1, HIGH);
  digitalWrite(MOTOR_B2, LOW);
  // Motors are not running
  analogWrite(ENABLE_MOTOR_A, MOTOR_STOPPED);
  analogWrite(ENABLE_MOTOR_B, MOTOR_STOPPED);
  // RGB LED is off
  analogWrite(REDPIN, RGBLED_OFF);
  analogWrite(GREENPIN, RGBLED_OFF);
  analogWrite(BLUEPIN, RGBLED_OFF);
}

/**
 * Updated the motor status accordingly with the motor control structure
 */
void updateMotors() {
  // Updated the direction
  if(drawing.directionA == MOTOR_CLOCKWISE) {
    digitalWrite(MOTOR_A1, HIGH);
    digitalWrite(MOTOR_A2, LOW);
  } else {
    digitalWrite(MOTOR_A1, LOW);
    digitalWrite(MOTOR_A2, HIGH);
  }
  if(drawing.directionB == MOTOR_CLOCKWISE) {
    digitalWrite(MOTOR_B1, HIGH);
    digitalWrite(MOTOR_B2, LOW);
  } else {
    digitalWrite(MOTOR_B1, LOW);
    digitalWrite(MOTOR_B2, HIGH);
  }
  // Set the current speed
  analogWrite(ENABLE_MOTOR_A, drawing.speedA);
  analogWrite(ENABLE_MOTOR_B, drawing.speedB);
}

/*
 * Executes one step of the colour cycling for the glowing LED
 */
void lightGlow() {
  // Set the RGB values
  analogWrite(REDPIN, glowing.valGlow); 
  analogWrite(GREENPIN, RGB_MAX - glowing.valGlow); 
  analogWrite(BLUEPIN, RGB_MID - glowing.valGlow); 
  // Update the value
  glowing.valGlow += glowing.directionGlow;
  // Check if the direction should be inverted
  if(glowing.valGlow > RGB_MAX) {
    glowing.valGlow = RGB_MAX - 1;
    glowing.directionGlow = RGB_DOWN;
  }
  if(glowing.valGlow < RGB_MIN) {
    glowing.valGlow = RGB_MIN + 1;
    glowing.directionGlow = RGB_UP;
  }
}

/*
 * Executes one step of the colour cycling for the glowing LED
 */
void lightMono() {
  // Set the RGB values
  analogWrite(REDPIN, 0); 
  analogWrite(GREENPIN, 4); 
  analogWrite(BLUEPIN, 0); 
  delay(5);
  analogWrite(REDPIN, 0); 
  analogWrite(GREENPIN, 0); 
  analogWrite(BLUEPIN, 0); 
}

void lightOff() {
  // Reset the LED to off and set the initial direction
  glowing.valGlow = RGBLED_OFF;
  glowing.directionGlow = RGB_UP;

  // Apply the values to the RGB LED
  analogWrite(REDPIN, glowing.valGlow); 
  analogWrite(GREENPIN, glowing.valGlow); 
  analogWrite(BLUEPIN, glowing.valGlow); 
}

// ========================================================================
//                                Cloud functions
// ========================================================================

/*
 * As the drawing status changes all the control parameters are updated, to 
 * keep the program status sunched with the controller on the cloud. In fact,
 * it is possible that the user has changed some parameter while the motor
 * was not running so on the next run the motors should start accordingly with 
 * the parameters set in the controller.
 */
void onStartDrawingChange() {
  // If drawing should start, the motor control structure is
  // updated to the current set values and the motors are started.
  // If the motors should stop instead, it is updated the motor 
  // contorl structure with the motor stop PWM value for both motors.
  if(StartDrawing == true) {
    drawing.speedA = SpeedMotor1;
    drawing.speedB = SpeedMotor2;
    // Check the directions status
    switch(Directions) {
      case DIRECITON_CLOCKWISE:
        drawing.directionA = MOTOR_CLOCKWISE;
        drawing.directionB = MOTOR_CLOCKWISE;
        break;
  
      case DIRECTION_COUNTERCLOCWISE:
        drawing.directionA = MOTOR_COUNTERCLOCKWISE;
        drawing.directionB = MOTOR_COUNTERCLOCKWISE;
        break;
  
      case DIRECTION_OPPOSITE:
        drawing.directionA = MOTOR_CLOCKWISE;
        drawing.directionB = MOTOR_COUNTERCLOCKWISE;
        break;
    }
  }
  else {
    drawing.speedA = MOTOR_STOPPED;
    drawing.speedB = MOTOR_STOPPED;
  }

  // Update the motor status
  updateMotors();
}

/*
 * Change the speed in the motor control structure and 
 * update the hardware status
 */
void onSpeedMotor1Change() {
  // Update the speed
  drawing.speedA = SpeedMotor1;
  // If drawing is on then update che changes immediately
  if(StartDrawing == true){
    // Update the motor status
    updateMotors();
  }
}

/*
 * Change the speed in the motor control structure and 
 * update the hardware status
 */
void onSpeedMotor2Change() {
  // Update the speed
  drawing.speedB = SpeedMotor2;
  // If drawing is on then update che changes immediately
  if(StartDrawing == true){
    // Update the motor status
    updateMotors();
  }
}

/*
 * Change the motors direction in the control structure and 
 * update the hardware status
 */
void onDirectionsChange() {
  // Check the directions status
  switch(Directions) {
    case DIRECITON_CLOCKWISE:
      drawing.directionA = MOTOR_CLOCKWISE;
      drawing.directionB = MOTOR_CLOCKWISE;
      break;

    case DIRECTION_COUNTERCLOCWISE:
      drawing.directionA = MOTOR_COUNTERCLOCKWISE;
      drawing.directionB = MOTOR_COUNTERCLOCKWISE;
      break;

    case DIRECTION_OPPOSITE:
      drawing.directionA = MOTOR_CLOCKWISE;
      drawing.directionB = MOTOR_COUNTERCLOCKWISE;
      break;
  }
  // If drawing is on then update che changes immediately
  if(StartDrawing == true){
    // Update the motor status
    updateMotors();
  }
}

/*
 * Enable/disable the RGB LED glowing mechanism
 * Note that if the light drawing is enables, the LED glowing is
 * automatic controlled by the main loop
 */
void onLightDrawingChange() {
  if(LightDrawing == false) {
    lightOff();
  }
}
